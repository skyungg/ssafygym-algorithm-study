// 무게가 서로 다른 n개의 물건
// 각물건은 1 ~ N 까지 번호
// 물건 쌍에 대해서 양팔저울로 어떤 게 더 무거운지 측정했음.

// 이 결과표에서 직접 측정하지 않은 물건쌍의 비교결과를 알아낼 수도
// 그렇지못할 수 있음.

// 어떤 게 더 크냐가 방향이됨.
// 비교 결과는 모순될 수 없음.
// 각 물건에 대해서 그 물건과의 비교 결과를 알 수 없는 물건의 개수를 출력
// 1번 물건과 비교해서 더 무거운지 안무거운지 알수 없는 개수를 구하라.
// 그래프가 연결되어 있지 않은 물건을 구하라라는 뜻
// union find임. -> 잘못된 생각

// 그래프 연결만으로 판단할 수 없음.
// 그래프 연결도 크냐작냐 비교 가능하게 하는 요소가 될 수 있지만
// 1번이 2번보다 크고 3번이 2번보다 클때 1번,2번,3번은 연결되어있어도
// 1번과 3번의 크기 비교를 할 수 없음.

// 따라서 방향을 설정하여 모든 쌍을 비교하는
// 플로이드 마셜을 활용해야함.

#include <iostream>
#include <vector>

using namespace std;

int n, m;   //물건의 개수 n, 쌍의 확인 m
int graph[101][101]; // n은 100개까지이므로 테이블은 100*100의 표로 관계표현가능

int main() {
    cin >> n >> m; // 입력

    // 초기화
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            graph[i][j] = 0; // 그래프를 0으로 만듦

    // 입력: a가 b보다 무겁다 → 방향 있음
    for (int i = 0; i < m; ++i) {
        int a, b; cin >> a >> b; 
        graph[a][b] = 1;   // a > b a방향에서 볼때는 1
        graph[b][a] = -1;  // b < a b방향에서 볼때는 -1
        // 양방향이 아니니 둘의 값을 다르게 적어줌
        // 한쪽이 결정되면 다른쪽도 당연히 결정되기에 -1로 적어줘야함.
    }

    // 플로이드-워셜
    for (int k = 1; k <= n; ++k) {
        // 경유지 k에 대해서 모든 썅 확인
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (graph[i][k] == 1 && graph[k][j] == 1)
                    graph[i][j] = 1;
                // k를 기점으로 i가 k보다 크고, k가 j보다 크면, i가 j보다 큼
                if (graph[i][k] == -1 && graph[k][j] == -1)
                    graph[i][j] = -1;
                // k를 기점으로 i가 k보다 작고 k가 j보다 작으면 i는 j보다 작음음
            }
        }
    }
    //모든 쌍의 -1, 1로 무게 측정완료

    // 비교 결과를 알 수 없는 개수 출력
    for (int i = 1; i <= n; ++i) {
        // 물건 선택
        int cnt = 0;
        for (int j = 1; j <= n; ++j) {
            // 다른 물건과 비교
            if (i == j) continue; // 자기자신과 비교할 수 없음으로 넘어감.
            if (graph[i][j] == 0) // 비교가 안된 것을 추가
                cnt++;
        }
        cout << cnt << "\n"; // i물건에 대해서 비교가 불가능한 물건의 개수 출력력
    }

    return 0;
}





// #include <iostream>
// #include <vector>

// using namespace std;

// // 무게가 서로 다른 n개의 물건
// // 각물건은 1 ~ N 까지 번호
// // 물건 쌍에 대해서 양팔저울로 어떤 게 더 무거운지 측정했음.

// // 이 결과표에서 직접 측정하지 않은 물건쌍의 비교결과를 알아낼 수도
// // 그렇지못할 수 있음.

// // 어떤 게 더 크냐가 방향이됨.
// // 비교 결과는 모순될 수 없음.
// // 각 물건에 대해서 그 물건과의 비교 결과를 알 수 없는 물건의 개수를 출력
// // 1번 물건과 비교해서 더 무거운지 안무거운지 알수 없는 개수를 구하라.
// // 그래프가 연결되어 있지 않은 물건을 구하라라는 뜻
// // union find임.

// int n; // 물건의 개수
// int m; // 물건 쌍의 개수, 앞의 물건이 뒤의 물건보다 더 무거움

// vector<int> parent; // 더 무거운 것이 index가 됨.

// int find(int x)
// {
//     if(parent[x] == x)
//     {
//         return x;
//     }
//     return parent[x] = find(parent[x]);
// }

// void union(int x, int y)
// {
//     x = find(x);
//     y = find(y);
// }

// int main()
// {
//     cin >> n >> m;
//     parent.resize(n + 1);
//     for(int i = 1; i <= n; i++)
//     {
//         parent[i] = i;
//     }
//     for(int i = 0; i < m; i++)
//     {
//         int a, b; cin >> a >> b;
//     }
//     for(int i = 1; i <= n; i++)
//     {
//         cout << n - find(i) << endl;
//     }
// }
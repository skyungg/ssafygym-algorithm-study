// 처음에 잘못 접근함.
// 음수가 없음에도 밸만포드를 쓰려고함.
// 음수가 없다 + 모든 노드를 확인할 필요가 있음 -> 플로이드-워셜을 써야함.
// 시작점이 정해지지 않았고, 모든 노드 간의 관계를 알아야
// 이동 범위를 확인할 수 있음.
// 플로이드 워셜은 완전탐색하고 비슷함.

// 플로이드 워셜은 n^3의 시간복잡도이지만
// 지역은 100, 수색범위 15, 길의 개수도 100개라 100*100*100 = 1000000 = 백만밖에 안됨.
// 플로이드 워셜은 i 노드와 j 노드 간의 최단 경로 거리를 구하는 것.
// 보통은 i-j를 바로 연결하는게 가까울테지만
// i-k-j를 k를 경유하는게 더 빠르면 k를 경유한 값으로 바꿈.
// 음의 가중치도 처리 가능하나 사이클은 없어야함.


// 거리 테이블은 2차원 배열로 표현이 가능하다는 것을 기억할 것.


#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int INF = 1e9; // 초기화용 큰수 

int main() {
    int n, m, r; // 지역번호, 수색범위, 길의 개수수
    cin >> n >> m >> r; // 입력

    vector<int> item(n + 1); // vector 초기화, item은 1번 지역부터 n번 지역까지
    for (int i = 1; i <= n; i++) cin >> item[i]; // 지역별 item 개수수 입력
    
    vector<vector<int>> dist(n + 1, vector<int>(n + 1, INF)); 
    // 거리 테이블 선언함. 2차원 벡터로, 행 n+1개, 열은 n+1개, 셀은 큰수로 초기화

    for (int i = 1; i <= n; i++) dist[i][i] = 0;
    // 경로는 같은 지역으로 다시 돌아갈 수 없으므로 1->1 같이 같은 지역으로 가는 것으 0으로 바꿈.

    for (int i = 0; i < r; i++) {
        int a, b, l;
        cin >> a >> b >> l; // a,b = 지역번호, l = 길의 길이
        dist[a][b] = min(dist[a][b], l);
        dist[b][a] = min(dist[b][a], l);
        // 도로는 양방향이기 때문에 [a][b]와 [b][a] 모두 갱신
        // 초기화에 의해 dist[a][b]는 큰수가 들어 있으니, 최소값을 고르면 l로 갱신됨.
    }
    // 초기 그래프가 완성되었으니 경유지와 그렇지 않은 곳을 계산

    // 플로이드-워셜: 모든 정점 쌍 최단거리 계산
    for (int k = 1; k <= n; k++) { // 경유노드
        for (int i = 1; i <= n; i++) { // 시작노드
            for (int j = 1; j <= n; j++) { //도착노드
                // 이런 순서에서는 i-k를 고정하고 도착 노드를 먼저 바꿔보는 방식
                // 도착지를 다 돌리고나면 시작점을 바꾸고, 도착지를 다시 돌림.
                // 모든 경유지 k에 대해서 도착과 시작점을 바꿔서 구함.
                if (dist[i][k] + dist[k][j] < dist[i][j])
                dist[i][j] = dist[i][k] + dist[k][j];
                // i-k 경로와 k-j 경로를 합친 것이 i-j 경로보다 짧으면 i-j 경로를 갱신
            }
        }
    }
    // 경유를 했을 때 더 작은 거리 그래프를 완성 시킬 수 있음.

    // 각 지역을 출발지로 할 때 얻을 수 있는 총 아이템 계산
    int answer = 0; //최대 아이템 개수를 저장할 변수
    for (int i = 1; i <= n; i++) { // 각 지역을 출발지로 할 때 얻을 수 있는 총 아이템 계산
        int sum = 0; // 초기화
        for (int j = 1; j <= n; j++) { // 각지역의 도착지역
            if (dist[i][j] <= m) sum += item[j]; 
            // i-j의 거리가 예은이의 수색범위 m보다 작다면 j지역의 아이템을 먹을 수 있음.
        }
        // for문이 다 돌면 i지역에서 갈 수 있는 모든 j지역의 item 개수는 sum에 저장됨.
        // 이제 answer와 sum을 비교해서 최대 아이템 개수를 갱신
        answer = max(answer, sum); // 최대 아이템 개수를 갱신
    }

    cout << answer << endl; // 최대 아이템 개수를 출력
    return 0;
}
